
! Copyright (C) 2015 Jon Lafuente and Manh Duc Le, 2017-18 Arsenii Gerasimov,
! Yaroslav Kvashnin and Lars Nordstrom.
! This file is distributed under the terms of the GNU General Public License.
! See the file COPYING for license details.

!BOP
! !ROUTINE: genw90input
! !INTERFACE:
subroutine genw90input
! !USES:
use modmain
use modw90
use modw90overlap
use modmpi
use modomp
! !DESCRIPTION:
!   Generates and writes out all basic files required for the Wannier90:
!   \begin{itemize}
!     \item {\tt seedname.eig} file with the Kohn-Sham eigenvalues (in eV),
!     \item {\tt seedname.mmn} file with $M_{mn}$ integrals,
!     \item {\tt seedname.amn} file with $A_{mn}$ integrals,
!     \item {\tt seedname.spn} file with matrix elements of $S$ between Bloch 
!           states (in case of spin-polarised calculation).
!   \end{itemize}
!   For the details about $M_{mn}$ and $A_{mn}$ integrals please look into
!   $genw90overlap$ routine description.
!
! !REVISION HISTORY:
!   Created March 2015 (Jon Lafuente and Manh Duc Le)
!   Modified July 2017 (Arsenii Gerasimov)
!EOP
!BOC
implicit none
!-------------------------------------------------------------------------------

! Generate global variables for the Wannier90 interface
call initw90
! Write out seedname.eig file
call genw90eig
! Generate and write out Mmn integrals
call genw90mmn
! Generate and write out S matrix elements
if ( nspinor .eq. 2 ) call genw90spn
! Generate and write out Amn integrals
call genw90amn

if ( mp_mpi ) then
  write(*,*)
  write(*,*) " Info(Wannier): Wannierization completed [ OK ]"
end if

reducek = reducek0

return


! LOCAL: subroutines
contains


! LOCAL: subroutine genw90eig
subroutine genw90eig
implicit none
! local variables
integer ikp,ig,ist
! allocatable arrays
real(8), allocatable :: evalsv_(:)
! automatic arrays
character(256) filename
!-------------------------------------------------------------------------------

filename = trim(wann_seedname)//'.eig'
open(500,file=filename,action='WRITE',form='FORMATTED')

allocate(evalsv_(nstsv))
do ikp = 1,nkpt
  call getevalsv(filext,ikp,vkl(:,ikp),evalsv_)
  do ig = 1,wann_nband
    ist = wann_bands(ig) ! AG :
    write(500,'(2I12,G18.10)') ig,ikp,( evalsv_(ist) - efermi )*ha_ev
  end do
end do
close(500)
deallocate(evalsv_)

if ( mp_mpi ) then
  write(*,*)
  write(*,*) " Info(Wannier): Eigenvalues has been written [ OK ]"
end if

end subroutine genw90eig


! LOCAL: subroutine genw90mmn
subroutine genw90mmn
implicit none
! local variables
integer nthd,ikp,inn,jk,n,m
real(8) gqc
! allocatable arrays
integer,    allocatable :: igpig(:,:),igpqig(:,:)
complex(8), allocatable :: wfmt(:,:,:,:),wfir(:,:,:),wfmtq(:,:,:,:),wfirq(:,:,:)
real(8),    allocatable :: jlgqr(:,:)
complex(8), allocatable :: ylmgq(:),sfacgq(:),expmt(:,:),mmn(:,:,:,:)
! automatic arrays
character(256) filename
character(10)  dat,tim
integer        ngp(nspnfv),ngpq(nspnfv)
real(8)        bqvec(3),bqc(3),vkql(3),vgqc(3)
!-------------------------------------------------------------------------------

filename = trim(wann_seedname)//'.mmn'
open(500,file=filename,action='WRITE',form='FORMATTED')

call date_and_time(date=dat,time=tim)
!   seedname.mmn file header
write(500,'("Generated by ELK on ",A4,"-",A2,"-",A2," at ",A2,":",A2,":",A2)')&
                          dat(1:4),dat(5:6),dat(7:8),tim(1:2),tim(3:4),tim(5:6)
write(500,'(3I8)') wann_nband,nkpt,wann_nntot

if( mp_mpi ) then
  write(*,*)
  write(*,*) " Info(Wannier): Mmn integrals calculation"
end if

ngrf = 1 ! Corresponds to expmt
! Synchronise MPI processes
call mpi_barrier(mpicom,ierror)
! Loop over reduced k-point set
call omp_hold(nkpt/np_mpi,nthd)
!$OMP PARALLEL DEFAULT(SHARED) &
!$OMP PRIVATE(ikp,inn,jk,n,m,bqvec,bqc,vkql,vgqc,gqc,jlgqr,ylmgq,sfacgq,expmt) &
!$OMP PRIVATE(ngp,igpig,wfmt,wfir,ngpq,igpqig,wfmtq,wfirq,mmn) &
!$OMP NUM_THREADS(nthd)

allocate(igpig(ngkmax,nspnfv),igpqig(ngkmax,nspnfv))
allocate(wfmt(npcmtmax,natmtot,nspinor,wann_nband))
allocate(wfmtq(npcmtmax,natmtot,nspinor,wann_nband))
allocate(wfir(ngtot,nspinor,wann_nband),wfirq(ngtot,nspinor,wann_nband))
allocate(jlgqr(njcmax,nspecies),ylmgq(lmmaxo),sfacgq(natmtot))
allocate(expmt(npcmtmax,natmtot))
allocate(mmn(wann_nband,nspinor,wann_nband,nspinor))

!$OMP DO
do ikp = 1,nkpt

  call genwfsvp(.false.,.false.,wann_nband,wann_bands,ngridg,igfft,vkl(:,ikp),&
                                                      ngp,igpig,wfmt,ngtot,wfir)

  ! Loop over ikp+b points
  do inn = 1,wann_nntot
    jk = nnlist(ikp,inn)
    bqvec = nncell(:,ikp,inn) + vkl(:,jk) - vkl(:,ikp)

    ! b-vector in Cartesian coordinates
    call r3mv(bvec,bqvec,bqc)
    ! Generate phase factor function exp(ibr) in the muffin-tins
    call gengqrf(bqc,vgqc,gqc,jlgqr,ylmgq,sfacgq)
    call genexpmt(1,jlgqr,ylmgq,1,sfacgq,expmt)

    ! k+b-vector in lattice coordinates
    vkql = vkl(:,ikp) + bqvec

    call genwfsvp(.false.,.false.,wann_nband,wann_bands,ngridg,igfft,vkql,&
                                                  ngpq,igpqig,wfmtq,ngtot,wfirq)

    ! Compute Mmn integrals
    call genw90overlap(wfmt,wfir,wann_nband,wfmtq,wfirq,mmn,expmt)

  ! Write Mmn integrals matrix elements
  !$OMP CRITICAL(genw90input_)
    write(500,'(5I8)') ikp,jk,nncell(:,ikp,inn)
    do n = 1,wann_nband
       do m = 1,wann_nband
        if ( nspinor .eq. 1 ) then
          write(500,'(2G18.10)') dble(mmn(m,1,n,1)),&
                                aimag(mmn(m,1,n,1))
        else
          write(500,'(2G18.10)') dble(mmn(m,1,n,1) + mmn(m,2,n,2)),&
                                aimag(mmn(m,1,n,1) + mmn(m,2,n,2))
        end if
       end do
    end do
  !$OMP END CRITICAL(genw90input_)

  end do ! End loop over b points

!$OMP CRITICAL(genw90input_)
  if ( mp_mpi ) then
    write(*,'("    Info(Wannier Mmn): completed ",I6," of ",I6," k-points")')&
                                                                   &ikp,nkpt
  end if
!$OMP END CRITICAL(genw90input_)

end do ! End loop over k points
!$OMP END DO

deallocate(mmn,expmt,jlgqr,ylmgq,sfacgq,wfmt,wfir,wfmtq,wfirq,igpig,igpqig)

!$OMP END PARALLEL
call omp_free(nthd)

if ( mp_mpi ) then
  write(*,*)
  write(*,*) " Info(Wannier): Mmn integrals has been computed [ OK ]"
end if

! Close seedname.mmn
close(500)

end subroutine genw90mmn


! LOCAL: subroutine genw90spn
subroutine genw90spn
implicit none
! local variables
integer nthd,ikp,is,m,n
real(8) gqc
! allocatable arrays
complex(8), allocatable :: spn_x(:,:),spn_y(:,:),spn_z(:,:)
integer,    allocatable :: igpig(:,:)
real(8),    allocatable :: jlgqr(:,:)
complex(8), allocatable :: ylmgq(:),sfacgq(:),expmt(:,:)
complex(8), allocatable :: wfmt(:,:,:,:),wfir(:,:,:),mmn(:,:,:,:)
! automatic arrays
character(256) filename
character(10)  dat,tim
integer        ngp(nspnfv)
real(8)        vec_0(3),vgqc(3)
!-------------------------------------------------------------------------------

! Open seedname.spn file
filename = trim(wann_seedname)//'.spn'
open(500,file=filename,action='WRITE',form='FORMATTED')

call date_and_time(date=dat,time=tim)
!   seedname.spn file header
write(500,'("Generated by ELK on ",A4,"-",A2,"-",A2," at ",A2,":",A2,":",A2)')&
                          dat(1:4),dat(5:6),dat(7:8),tim(1:2),tim(3:4),tim(5:6)
write(500,'(3I8)') wann_nband,nkpt

if ( mp_mpi ) then
  write(*,*)
  write(*,*) " Info(Wannier): Spn calculation"
end if

allocate(spn_x(nkpt,(wann_nband*( wann_nband + 1 ))/2))
allocate(spn_y(nkpt,(wann_nband*( wann_nband + 1 ))/2))
allocate(spn_z(nkpt,(wann_nband*( wann_nband + 1 ))/2))

ngrf = 1 ! Corresponds to expmt
! Synchronise MPI processes
call mpi_barrier(mpicom,ierror)
! Loop over reduced k-point set
call omp_hold(nkpt/np_mpi,nthd)
!$OMP PARALLEL DEFAULT(SHARED) &
!$OMP PRIVATE(ikp,is,m,n,vgqc,gqc,jlgqr,ylmgq,sfacgq,expmt,ngp,igpig,wfmt,wfir)&
!$OMP PRIVATE(mmn) &
!$OMP NUM_THREADS(nthd)

allocate(igpig(ngkmax,nspnfv))
allocate(wfmt(npcmtmax,natmtot,nspinor,wann_nband))
allocate(wfir(ngtot,nspinor,wann_nband))
allocate(jlgqr(njcmax,nspecies),ylmgq(lmmaxo),sfacgq(natmtot))
allocate(expmt(npcmtmax,natmtot))
allocate(mmn(wann_nband,nspinor,wann_nband,nspinor))

!$OMP DO
do ikp = 1,nkpt

  call genwfsvp(.false.,.false.,wann_nband,wann_bands,ngridg,igfft,vkl(:,ikp),&
                                                      ngp,igpig,wfmt,ngtot,wfir)

  ! If wavefunctions are spinors, compute S matrix by default
  vec_0(1) = 0.d0; vec_0(2) = 0.d0; vec_0(3) = 0.d0
  call gengqrf(vec_0,vgqc,gqc,jlgqr,ylmgq,sfacgq)
  call genexpmt(1,jlgqr,ylmgq,1,sfacgq,expmt)

  call genw90overlap(wfmt,wfir,wann_nband,wfmt,wfir,mmn,expmt)

  is = 1
  do m = 1,wann_nband
    do n = 1,m
      spn_x(ikp,is) =   mmn(n,1,m,2) + mmn(n,2,m,1)
      spn_y(ikp,is) = ( mmn(n,2,m,1) - mmn(n,1,m,2) )*zi
      spn_z(ikp,is) =   mmn(n,1,m,1) - mmn(n,2,m,2)
      is = is + 1
    end do
  end do

!$OMP CRITICAL(genw90input_)
  if ( mp_mpi ) then
    write(*,'("    Info(Wannier Spn): completed ",I6," of ",I6," k-points")')&
                                                                   &ikp,nkpt
  end if
!$OMP END CRITICAL(genw90input_)

end do ! End loop over k points
!$OMP END DO

deallocate(mmn,jlgqr,ylmgq,sfacgq,expmt,wfmt,wfir,igpig)

!$OMP END PARALLEL
call omp_free(nthd)

! Write seedname.spn
do ikp = 1,nkpt
  do is = 1,(wann_nband*( wann_nband + 1 ))/2
    write(500,'(2G18.10)') spn_x(ikp,is)
    write(500,'(2G18.10)') spn_y(ikp,is)
    write(500,'(2G18.10)') spn_z(ikp,is)
  end do
end do

! Close seedname.spn
close(500)

if ( mp_mpi ) then
  write(*,*)
  write(*,*) " Info(Wannier): Spn has been computed [ OK ]"
end if

deallocate(spn_x,spn_y,spn_z)

end subroutine genw90spn


end subroutine genw90input
!EOC
